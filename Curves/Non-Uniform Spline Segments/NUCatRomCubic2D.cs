// by Freya Holmér (https://github.com/FreyaHolmer/Mathfs)

using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace Freya {

	/// <summary>A non-uniform cubic catmull-rom 2D curve</summary>
	[Serializable] public struct NUCatRomCubic2D : IParamCubicSplineSegment2D {

		public enum KnotCalcMode {
			Manual,
			Auto,
			AutoUnitInterval
		}

		const MethodImplOptions INLINE = MethodImplOptions.AggressiveInlining;

		#region Constructors

		/// <summary>Creates a cubic catmull-rom curve, from 4 control points and their corresponding knot values</summary>
		/// <param name="p0">The first control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</param>
		/// <param name="p1">The second control point, and the start of the catrom curve</param>
		/// <param name="p2">The third control point, and the end of the catrom curve</param>
		/// <param name="p3">The last control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</param>
		/// <param name="k0">The first knot value</param>
		/// <param name="k1">The second knot value</param>
		/// <param name="k2">The third knot value</param>
		/// <param name="k3">The fourth knot value</param>
		public NUCatRomCubic2D( Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float k0, float k1, float k2, float k3 ) {
			( this.p0, this.p1, this.p2, this.p3 ) = ( p0, p1, p2, p3 );
			( this.k0, this.k1, this.k2, this.k3 ) = ( k0, k1, k2, k3 );
			validCoefficients = false;
			curve = default;
			knotCalcMode = KnotCalcMode.Manual;
			alpha = default; // unused when using manual knots
		}

		/// <summary>Creates a uniform cubic catmull-rom curve, from 4 control points</summary>
		/// <param name="p0">The first control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</param>
		/// <param name="p1">The second control point, and the start of the catrom curve</param>
		/// <param name="p2">The third control point, and the end of the catrom curve</param>
		/// <param name="p3">The last control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</param>
		public NUCatRomCubic2D( Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3 ) : this( p0, p1, p2, p3, -1, 0, 1, 2 ) {
		}

		/// <summary>Creates a cubic catmull-rom curve, from 4 control points with explicit type for auto-generating its knot values</summary>
		/// <param name="p0">The first control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</param>
		/// <param name="p1">The second control point, and the start of the catrom curve</param>
		/// <param name="p2">The third control point, and the end of the catrom curve</param>
		/// <param name="p3">The last control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</param>
		/// <param name="type">The type of catrom curve to use. This will internally determine the value of the <c>alpha</c> parameter</param>
		/// <param name="parameterizeToUnitInterval">If true, the knot generation will ensure k1 = 0 and k2 = 1,
		/// making it span the unit interval of 0 to 1, instead of using the raw knot values generated by the alpha parameterization</param>
		public NUCatRomCubic2D( Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, CatRomType type, bool parameterizeToUnitInterval = true )
			: this( p0, p1, p2, p3, type.AlphaValue(), parameterizeToUnitInterval ) {
		}

		/// <summary>Creates a cubic catmull-rom curve, from 4 control points with explicit alpha parameter to define its type</summary>
		/// <param name="p0">The first control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</param>
		/// <param name="p1">The second control point, and the start of the catrom curve</param>
		/// <param name="p2">The third control point, and the end of the catrom curve</param>
		/// <param name="p3">The last control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</param>
		/// <param name="alpha">The alpha parameter controls how much the length of each segment should influence the knot values, which in turn influence the shape of the curve.
		/// A value of 0 is called a uniform catrom, and is fast to evaluate but has a tendency to overshoot.
		/// A value of 0.5 is a centripetal catrom, which follows points very tightly, and prevents cusps and loops.
		/// A value of 1 is a chordal catrom, which follows the points very smoothly with wide arcs</param>
		/// <param name="parameterizeToUnitInterval">If true, the knot generation will ensure k1 = 0 and k2 = 1,
		/// making it span the unit interval of 0 to 1 instead of using the raw knot values generated by the alpha parameterization</param>
		public NUCatRomCubic2D( Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float alpha, bool parameterizeToUnitInterval = true ) {
			( this.p0, this.p1, this.p2, this.p3 ) = ( p0, p1, p2, p3 );
			validCoefficients = false;
			curve = default;
			k0 = k1 = k2 = k3 = default;
			knotCalcMode = parameterizeToUnitInterval ? KnotCalcMode.AutoUnitInterval : KnotCalcMode.Auto;
			this.alpha = alpha;
		}

		#endregion

		// serialized data
		[SerializeField] Vector2 p0, p1, p2, p3;
		[SerializeField] float k0, k1, k2, k3; // knot vector

		// knot auto-calculation fields
		[SerializeField] KnotCalcMode knotCalcMode; // knot recalculation mode
		[SerializeField] float alpha; // alpha parameterization

		Polynomial2D curve;
		public Polynomial2D Curve {
			get {
				ReadyCoefficients();
				return curve;
			}
		}

		#region Properties

		/// <summary>The first control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</summary>
		public Vector2 P0 {
			[MethodImpl( INLINE )] get => p0;
			set => _ = ( p0 = value, validCoefficients = false );
		}
		/// <summary>The second control point, and the start of the catrom curve</summary>
		public Vector2 P1 {
			[MethodImpl( INLINE )] get => p1;
			set => _ = ( p1 = value, validCoefficients = false );
		}
		/// <summary>The third control point, and the end of the catrom curve</summary>
		public Vector2 P2 {
			[MethodImpl( INLINE )] get => p2;
			set => _ = ( p2 = value, validCoefficients = false );
		}
		/// <summary>The last control point of the catrom curve. Note that this point is not included in the curve itself, and only helps to shape it</summary>
		public Vector2 P3 {
			[MethodImpl( INLINE )] get => p3;
			set => _ = ( p3 = value, validCoefficients = false );
		}

		/// <summary>The alpha parameter, which controls how much the length of each segment should influence the shape of the curve.
		/// A value of 0 is called a uniform catrom, and is fast to evaluate but has a tendency to overshoot.
		/// A value of 0.5 is a centripetal catrom, which follows points very tightly, and prevents cusps and loops.
		/// A value of 1 is a chordal catrom, which follows the points very smoothly with wide arcs</summary>
		public float Alpha {
			[MethodImpl( INLINE )] get => alpha;
			set => _ = ( alpha = value, validCoefficients = false );
		}

		#endregion

		// cached data to accelerate calculations
		[NonSerialized] bool validCoefficients; // inverted isDirty flag (can't default to true in structs)

		[MethodImpl( INLINE )] void ReadyCoefficients() {
			if( validCoefficients )
				return; // no need to update
			validCoefficients = true;
			if( knotCalcMode != KnotCalcMode.Manual )
				( k0, k1, k2, k3 ) = SplineUtils.CalcCatRomKnots( p0, p1, p2, p3, alpha, knotCalcMode == KnotCalcMode.AutoUnitInterval );
			curve = SplineUtils.CalculateCatRomCurve( p0, p1, p2, p3, k0, k1, k2, k3 );
		}

		/// <summary>Returns the weight of the given control point at the given parameter value</summary>
		/// <param name="i">The point to get the weight of</param>
		/// <param name="u">The parameter value at which to sample the weight</param>
		public float GetPointWeightAtKnotValue( int i, float u ) {
			float a = Mathfs.InverseLerp( k0, k1, u );
			float b = Mathfs.InverseLerp( k1, k2, u );
			float c = Mathfs.InverseLerp( k2, k3, u );
			float d = Mathfs.InverseLerp( k0, k2, u );
			float g = Mathfs.InverseLerp( k1, k3, u );
			switch( i ) {
				case 0:  return -( a - 1 ) * ( b - 1 ) * ( d - 1 );
				case 1:  return ( b - 1 ) * ( a * d - a + b * ( d + g - 1 ) - d );
				case 2:  return -b * ( b * ( d + g - 1 ) + g * ( c - 1 ) - d );
				case 3:  return b * c * g;
				default: throw new IndexOutOfRangeException( $"Catrom point has to be either 0, 1, 2 or 3. Got: {i}" );
			}
		}

	}

}