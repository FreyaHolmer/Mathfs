// by Freya Holmér (https://github.com/FreyaHolmer/Mathfs)
// Do not manually edit - this file is generated by MathfsCodegen.cs

using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace Freya {

	/// <summary>An optimized uniform 4D Cubic bézier segment, with 4 control points</summary>
	[Serializable] public struct BezierCubic4D : IParamSplineSegment<Polynomial4D,Vector4Matrix4x1> {

		const MethodImplOptions INLINE = MethodImplOptions.AggressiveInlining;

		[SerializeField] Vector4Matrix4x1 pointMatrix;
		[NonSerialized] Polynomial4D curve;
		[NonSerialized] bool validCoefficients;

		/// <summary>Creates a uniform 4D Cubic bézier segment, from 4 control points</summary>
		/// <param name="p0">The starting point of the curve</param>
		/// <param name="p1">The second control point of the curve, sometimes called the start tangent point</param>
		/// <param name="p2">The third control point of the curve, sometimes called the end tangent point</param>
		/// <param name="p3">The end point of the curve</param>
		public BezierCubic4D( Vector4 p0, Vector4 p1, Vector4 p2, Vector4 p3 ) : this(new Vector4Matrix4x1(p0, p1, p2, p3)){}
		/// <summary>Creates a uniform 4D Cubic bézier segment, from 4 control points</summary>
		/// <param name="pointMatrix">The matrix containing the control points of this spline</param>
		public BezierCubic4D( Vector4Matrix4x1 pointMatrix ) => (this.pointMatrix,curve,validCoefficients) = (pointMatrix,default,false);

		public Polynomial4D Curve {
			get {
				if( validCoefficients )
					return curve; // no need to update
				validCoefficients = true;
				return curve = new Polynomial4D(
					P0,
					3*(-P0+P1),
					3*P0-6*P1+3*P2,
					-P0+3*P1-3*P2+P3
				);
			}
		}
		public Vector4Matrix4x1 PointMatrix {[MethodImpl( INLINE )] get => pointMatrix; [MethodImpl( INLINE )] set => _ = ( pointMatrix = value, validCoefficients = false ); }
		/// <summary>The starting point of the curve</summary>
		public Vector4 P0{ [MethodImpl( INLINE )] get => pointMatrix.m0; [MethodImpl( INLINE )] set => _ = ( pointMatrix.m0 = value, validCoefficients = false ); }
		/// <summary>The second control point of the curve, sometimes called the start tangent point</summary>
		public Vector4 P1{ [MethodImpl( INLINE )] get => pointMatrix.m1; [MethodImpl( INLINE )] set => _ = ( pointMatrix.m1 = value, validCoefficients = false ); }
		/// <summary>The third control point of the curve, sometimes called the end tangent point</summary>
		public Vector4 P2{ [MethodImpl( INLINE )] get => pointMatrix.m2; [MethodImpl( INLINE )] set => _ = ( pointMatrix.m2 = value, validCoefficients = false ); }
		/// <summary>The end point of the curve</summary>
		public Vector4 P3{ [MethodImpl( INLINE )] get => pointMatrix.m3; [MethodImpl( INLINE )] set => _ = ( pointMatrix.m3 = value, validCoefficients = false ); }
		/// <summary>Get or set a control point position by index. Valid indices from 0 to 3</summary>
		public Vector4 this[ int i ] {
			get => i switch { 0 => P0, 1 => P1, 2 => P2, 3 => P3, _ => throw new ArgumentOutOfRangeException( nameof(i), $"Index has to be in the 0 to 3 range, and I think {i} is outside that range you know" ) };
			set { switch( i ){ case 0: P0 = value; break; case 1: P1 = value; break; case 2: P2 = value; break; case 3: P3 = value; break; default: throw new ArgumentOutOfRangeException( nameof(i), $"Index has to be in the 0 to 3 range, and I think {i} is outside that range you know" ); }}
		}
		public static bool operator ==( BezierCubic4D a, BezierCubic4D b ) => a.pointMatrix == b.pointMatrix;
		public static bool operator !=( BezierCubic4D a, BezierCubic4D b ) => !( a == b );
		public bool Equals( BezierCubic4D other ) => P0.Equals( other.P0 ) && P1.Equals( other.P1 ) && P2.Equals( other.P2 ) && P3.Equals( other.P3 );
		public override bool Equals( object obj ) => obj is BezierCubic4D other && pointMatrix.Equals( other.pointMatrix );
		public override int GetHashCode() => pointMatrix.GetHashCode();
		public override string ToString() => $"({pointMatrix.m0}, {pointMatrix.m1}, {pointMatrix.m2}, {pointMatrix.m3})";

		public static explicit operator HermiteCubic4D( BezierCubic4D s ) =>
			new HermiteCubic4D(
				s.P0,
				3*(-s.P0+s.P1),
				s.P3,
				3*(-s.P2+s.P3)
			);
		public static explicit operator CatRomCubic4D( BezierCubic4D s ) =>
			new CatRomCubic4D(
				6*s.P0-6*s.P1+s.P3,
				s.P0,
				s.P3,
				s.P0-6*s.P2+6*s.P3
			);
		public static explicit operator UBSCubic4D( BezierCubic4D s ) =>
			new UBSCubic4D(
				6*s.P0-7*s.P1+2*s.P2,
				2*s.P1-s.P2,
				-s.P1+2*s.P2,
				2*s.P1-7*s.P2+6*s.P3
			);
		/// <summary>Returns a linear blend between two bézier curves</summary>
		/// <param name="a">The first spline segment</param>
		/// <param name="b">The second spline segment</param>
		/// <param name="t">A value from 0 to 1 to blend between <c>a</c> and <c>b</c></param>
		public static BezierCubic4D Lerp( BezierCubic4D a, BezierCubic4D b, float t ) =>
			new(
				Vector4.LerpUnclamped( a.P0, b.P0, t ),
				Vector4.LerpUnclamped( a.P1, b.P1, t ),
				Vector4.LerpUnclamped( a.P2, b.P2, t ),
				Vector4.LerpUnclamped( a.P3, b.P3, t )
			);
		/// <summary>Splits this curve at the given t-value, into two curves that together form the exact same shape</summary>
		/// <param name="t">The t-value to split at</param>
		public (BezierCubic4D pre, BezierCubic4D post) Split( float t ) {
			Vector4 a = new Vector4(
				P0.x + ( P1.x - P0.x ) * t,
				P0.y + ( P1.y - P0.y ) * t,
				P0.z + ( P1.z - P0.z ) * t,
				P0.w + ( P1.w - P0.w ) * t );
			Vector4 b = new Vector4(
				P1.x + ( P2.x - P1.x ) * t,
				P1.y + ( P2.y - P1.y ) * t,
				P1.z + ( P2.z - P1.z ) * t,
				P1.w + ( P2.w - P1.w ) * t );
			Vector4 c = new Vector4(
				P2.x + ( P3.x - P2.x ) * t,
				P2.y + ( P3.y - P2.y ) * t,
				P2.z + ( P3.z - P2.z ) * t,
				P2.w + ( P3.w - P2.w ) * t );
			Vector4 d = new Vector4(
				a.x + ( b.x - a.x ) * t,
				a.y + ( b.y - a.y ) * t,
				a.z + ( b.z - a.z ) * t,
				a.w + ( b.w - a.w ) * t );
			Vector4 e = new Vector4(
				b.x + ( c.x - b.x ) * t,
				b.y + ( c.y - b.y ) * t,
				b.z + ( c.z - b.z ) * t,
				b.w + ( c.w - b.w ) * t );
			Vector4 p = new Vector4(
				d.x + ( e.x - d.x ) * t,
				d.y + ( e.y - d.y ) * t,
				d.z + ( e.z - d.z ) * t,
				d.w + ( e.w - d.w ) * t );
			return ( new BezierCubic4D( P0, a, d, p ), new BezierCubic4D( p, e, c, P3 ) );
		}
	}
}
